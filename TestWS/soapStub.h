/* soapStub.h
   Generated by gSOAP 2.8.36 for OGService.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns2	"http://tempuri.org/Imports"
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"
#define SOAP_NAMESPACE_OF_ns3	"http://schemas.microsoft.com/2003/10/Serialization/"
#define SOAP_NAMESPACE_OF_ns4	"http://schemas.datacontract.org/2004/07/OpenGloveWCF"
#define SOAP_NAMESPACE_OF_ns5	"http://schemas.microsoft.com/2003/10/Serialization/Arrays"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20836
# error "GSOAP VERSION 20836 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* OGService.h:552 */
#ifndef SOAP_TYPE_ns4__Side
#define SOAP_TYPE_ns4__Side (100)
/* ns4:Side */
enum ns4__Side {
	ns4__Side__Right = 0,
	ns4__Side__Left = 1
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* OGService.h:165 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* OGService.h:162 */
class xsd__base64Binary;	/* OGService.h:168 */
class xsd__ID_;	/* OGService.h:186 */
class xsd__IDREF_;	/* OGService.h:196 */
class xsd__QName_;	/* OGService.h:203 */
class xsd__anyURI_;	/* OGService.h:213 */
class xsd__base64Binary_;	/* OGService.h:220 */
class xsd__boolean;	/* OGService.h:227 */
class xsd__byte_;	/* OGService.h:234 */
class xsd__dateTime;	/* OGService.h:241 */
class xsd__decimal_;	/* OGService.h:251 */
class xsd__double;	/* OGService.h:258 */
class xsd__duration_;	/* OGService.h:268 */
class xsd__float;	/* OGService.h:275 */
class xsd__int;	/* OGService.h:282 */
class xsd__long;	/* OGService.h:289 */
class xsd__short;	/* OGService.h:296 */
class xsd__string;	/* OGService.h:303 */
class xsd__unsignedByte_;	/* OGService.h:310 */
class xsd__unsignedInt;	/* OGService.h:317 */
class xsd__unsignedLong;	/* OGService.h:324 */
class xsd__unsignedShort;	/* OGService.h:331 */
class ns3__char__;	/* OGService.h:510 */
class ns3__duration__;	/* OGService.h:523 */
class ns3__guid__;	/* OGService.h:535 */
class ns4__Side_;	/* OGService.h:559 */
class _ns1__GetGloves;	/* OGService.h:345 */
class _ns1__GetGlovesResponse;	/* OGService.h:348 */
class _ns1__RefreshGloves;	/* OGService.h:351 */
class _ns1__RefreshGlovesResponse;	/* OGService.h:354 */
class _ns1__SaveGlove;	/* OGService.h:357 */
class _ns1__SaveGloveResponse;	/* OGService.h:360 */
class _ns1__Activate;	/* OGService.h:363 */
class _ns1__ActivateResponse;	/* OGService.h:366 */
class _ns1__Connect;	/* OGService.h:369 */
class _ns1__ConnectResponse;	/* OGService.h:372 */
class _ns1__Disconnect;	/* OGService.h:375 */
class _ns1__DisconnectResponse;	/* OGService.h:378 */
class _ns1__ActivateMany;	/* OGService.h:381 */
class _ns1__ActivateManyResponse;	/* OGService.h:384 */
class _ns1__addFlexor;	/* OGService.h:387 */
class _ns1__addFlexorResponse;	/* OGService.h:390 */
class _ns1__removeFlexor;	/* OGService.h:393 */
class _ns1__removeFlexorResponse;	/* OGService.h:396 */
class _ns1__calibrateFlexors;	/* OGService.h:399 */
class _ns1__calibrateFlexorsResponse;	/* OGService.h:402 */
class _ns1__confirmCalibration;	/* OGService.h:405 */
class _ns1__confirmCalibrationResponse;	/* OGService.h:408 */
class _ns1__setThreshold;	/* OGService.h:411 */
class _ns1__setThresholdResponse;	/* OGService.h:414 */
class _ns1__resetFlexors;	/* OGService.h:417 */
class _ns1__resetFlexorsResponse;	/* OGService.h:420 */
class _ns1__startIMU;	/* OGService.h:423 */
class _ns1__startIMUResponse;	/* OGService.h:426 */
class _ns1__setIMUStatus;	/* OGService.h:429 */
class _ns1__setIMUStatusResponse;	/* OGService.h:432 */
class _ns1__setRawData;	/* OGService.h:435 */
class _ns1__setRawDataResponse;	/* OGService.h:438 */
class ns4__ArrayOfGlove;	/* OGService.h:441 */
class ns4__Glove;	/* OGService.h:444 */
class ns4__Glove_x002eConfiguration;	/* OGService.h:447 */
class ns4__Glove_x002eConfiguration_x002eProfile;	/* OGService.h:450 */
class ns5__ArrayOfint;	/* OGService.h:453 */
class ns5__ArrayOfstring;	/* OGService.h:456 */
class _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint;	/* OGService.h:1468 */
class ns5__ArrayOfKeyValueOfintint;	/* OGService.h:459 */
class _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring;	/* OGService.h:1503 */
class ns5__ArrayOfKeyValueOfstringstring;	/* OGService.h:462 */
struct __ns1__GetGloves;	/* OGService.h:1849 */
struct __ns1__RefreshGloves;	/* OGService.h:1919 */
struct __ns1__SaveGlove;	/* OGService.h:1989 */
struct __ns1__Activate;	/* OGService.h:2059 */
struct __ns1__Connect;	/* OGService.h:2129 */
struct __ns1__Disconnect;	/* OGService.h:2199 */
struct __ns1__ActivateMany;	/* OGService.h:2269 */
struct __ns1__addFlexor;	/* OGService.h:2339 */
struct __ns1__removeFlexor;	/* OGService.h:2409 */
struct __ns1__calibrateFlexors;	/* OGService.h:2479 */
struct __ns1__confirmCalibration;	/* OGService.h:2549 */
struct __ns1__setThreshold;	/* OGService.h:2619 */
struct __ns1__resetFlexors;	/* OGService.h:2689 */
struct __ns1__startIMU;	/* OGService.h:2759 */
struct __ns1__setIMUStatus;	/* OGService.h:2829 */
struct __ns1__setRawData;	/* OGService.h:2899 */

/* OGService.h:162 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (11)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType()
        {
          __item = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:168 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (15)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary()
        {
          __ptr = (unsigned char *)0;
          __size = 0;
          id = NULL;
          type = (char *)0;
          options = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:186 */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (22)
/* Type xsd__ID_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:ID': */
class SOAP_CMAC xsd__ID_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:ID' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__ID_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID_, default initialized and not managed by a soap context
        virtual xsd__ID_ *soap_alloc(void) const { return SOAP_NEW(xsd__ID_); }
      public:
        /// Constructor with initializations
        xsd__ID_()
        {
        }
        virtual ~xsd__ID_() { }
        /// Friend allocator used by soap_new_xsd__ID_(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID_ * SOAP_FMAC2 soap_instantiate_xsd__ID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:196 */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (24)
/* Type xsd__IDREF_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:IDREF': */
class SOAP_CMAC xsd__IDREF_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:IDREF' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__IDREF_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF_, default initialized and not managed by a soap context
        virtual xsd__IDREF_ *soap_alloc(void) const { return SOAP_NEW(xsd__IDREF_); }
      public:
        /// Constructor with initializations
        xsd__IDREF_()
        {
        }
        virtual ~xsd__IDREF_() { }
        /// Friend allocator used by soap_new_xsd__IDREF_(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF_ * SOAP_FMAC2 soap_instantiate_xsd__IDREF_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:203 */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (25)
/* Type xsd__QName_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:QName': */
class SOAP_CMAC xsd__QName_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__QName_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName_, default initialized and not managed by a soap context
        virtual xsd__QName_ *soap_alloc(void) const { return SOAP_NEW(xsd__QName_); }
      public:
        /// Constructor with initializations
        xsd__QName_()
        {
        }
        virtual ~xsd__QName_() { }
        /// Friend allocator used by soap_new_xsd__QName_(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:213 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (27)
/* Type xsd__anyURI_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyURI_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
        virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
      public:
        /// Constructor with initializations
        xsd__anyURI_()
        {
        }
        virtual ~xsd__anyURI_() { }
        /// Friend allocator used by soap_new_xsd__anyURI_(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:220 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (28)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_()
        {
        }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:227 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (29)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean()
        {
          __item = (bool)0;
        }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:234 */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (31)
/* Type xsd__byte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:byte': */
class SOAP_CMAC xsd__byte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__byte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte_, default initialized and not managed by a soap context
        virtual xsd__byte_ *soap_alloc(void) const { return SOAP_NEW(xsd__byte_); }
      public:
        /// Constructor with initializations
        xsd__byte_()
        {
          __item = (char)0;
        }
        virtual ~xsd__byte_() { }
        /// Friend allocator used by soap_new_xsd__byte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte_ * SOAP_FMAC2 soap_instantiate_xsd__byte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:241 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (32)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime()
        {
          __item = (time_t)0;
        }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:251 */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (35)
/* Type xsd__decimal_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:decimal': */
class SOAP_CMAC xsd__decimal_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:decimal' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__decimal_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal_, default initialized and not managed by a soap context
        virtual xsd__decimal_ *soap_alloc(void) const { return SOAP_NEW(xsd__decimal_); }
      public:
        /// Constructor with initializations
        xsd__decimal_()
        {
        }
        virtual ~xsd__decimal_() { }
        /// Friend allocator used by soap_new_xsd__decimal_(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal_ * SOAP_FMAC2 soap_instantiate_xsd__decimal_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:258 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (36)
/* Type xsd__double is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:double': */
class SOAP_CMAC xsd__double : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__double; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double, default initialized and not managed by a soap context
        virtual xsd__double *soap_alloc(void) const { return SOAP_NEW(xsd__double); }
      public:
        /// Constructor with initializations
        xsd__double()
        {
          __item = (double)0;
        }
        virtual ~xsd__double() { }
        /// Friend allocator used by soap_new_xsd__double(struct soap*, int)
        friend SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:268 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (39)
/* Type xsd__duration_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:duration': */
class SOAP_CMAC xsd__duration_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__duration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
        virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
      public:
        /// Constructor with initializations
        xsd__duration_()
        {
        }
        virtual ~xsd__duration_() { }
        /// Friend allocator used by soap_new_xsd__duration_(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:275 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (40)
/* Type xsd__float is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:float': */
class SOAP_CMAC xsd__float : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__float; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float, default initialized and not managed by a soap context
        virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
      public:
        /// Constructor with initializations
        xsd__float()
        {
          __item = (float)0;
        }
        virtual ~xsd__float() { }
        /// Friend allocator used by soap_new_xsd__float(struct soap*, int)
        friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:282 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (42)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int()
        {
          __item = (int)0;
        }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:289 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (43)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long()
        {
          __item = (LONG64)0;
        }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:296 */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (45)
/* Type xsd__short is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:short': */
class SOAP_CMAC xsd__short : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__short; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short, default initialized and not managed by a soap context
        virtual xsd__short *soap_alloc(void) const { return SOAP_NEW(xsd__short); }
      public:
        /// Constructor with initializations
        xsd__short()
        {
          __item = (short)0;
        }
        virtual ~xsd__short() { }
        /// Friend allocator used by soap_new_xsd__short(struct soap*, int)
        friend SOAP_FMAC1 xsd__short * SOAP_FMAC2 soap_instantiate_xsd__short(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:303 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (47)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string()
        {
        }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:310 */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (48)
/* Type xsd__unsignedByte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedByte': */
class SOAP_CMAC xsd__unsignedByte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte_, default initialized and not managed by a soap context
        virtual xsd__unsignedByte_ *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedByte_); }
      public:
        /// Constructor with initializations
        xsd__unsignedByte_()
        {
          __item = (unsigned char)0;
        }
        virtual ~xsd__unsignedByte_() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:317 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (49)
/* Type xsd__unsignedInt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
        virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
      public:
        /// Constructor with initializations
        xsd__unsignedInt()
        {
          __item = (unsigned int)0;
        }
        virtual ~xsd__unsignedInt() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:324 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (50)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong()
        {
          __item = (ULONG64)0;
        }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:331 */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (52)
/* Type xsd__unsignedShort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort, default initialized and not managed by a soap context
        virtual xsd__unsignedShort *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedShort); }
      public:
        /// Constructor with initializations
        xsd__unsignedShort()
        {
          __item = (unsigned short)0;
        }
        virtual ~xsd__unsignedShort() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:510 */
#ifndef SOAP_TYPE_ns3__char__
#define SOAP_TYPE_ns3__char__ (95)
/* Type ns3__char__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:char': */
class SOAP_CMAC ns3__char__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__char__
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__char__, default initialized and not managed by a soap context
        virtual ns3__char__ *soap_alloc(void) const { return SOAP_NEW(ns3__char__); }
      public:
        /// Constructor with initializations
        ns3__char__()
        {
          __item = (int)0;
        }
        virtual ~ns3__char__() { }
        /// Friend allocator used by soap_new_ns3__char__(struct soap*, int)
        friend SOAP_FMAC1 ns3__char__ * SOAP_FMAC2 soap_instantiate_ns3__char__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:523 */
#ifndef SOAP_TYPE_ns3__duration__
#define SOAP_TYPE_ns3__duration__ (97)
/* Type ns3__duration__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:duration': */
class SOAP_CMAC ns3__duration__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__duration__
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__duration__, default initialized and not managed by a soap context
        virtual ns3__duration__ *soap_alloc(void) const { return SOAP_NEW(ns3__duration__); }
      public:
        /// Constructor with initializations
        ns3__duration__()
        {
        }
        virtual ~ns3__duration__() { }
        /// Friend allocator used by soap_new_ns3__duration__(struct soap*, int)
        friend SOAP_FMAC1 ns3__duration__ * SOAP_FMAC2 soap_instantiate_ns3__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:535 */
#ifndef SOAP_TYPE_ns3__guid__
#define SOAP_TYPE_ns3__guid__ (99)
/* Type ns3__guid__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:guid': */
class SOAP_CMAC ns3__guid__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:guid' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__guid__
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__guid__, default initialized and not managed by a soap context
        virtual ns3__guid__ *soap_alloc(void) const { return SOAP_NEW(ns3__guid__); }
      public:
        /// Constructor with initializations
        ns3__guid__()
        {
        }
        virtual ~ns3__guid__() { }
        /// Friend allocator used by soap_new_ns3__guid__(struct soap*, int)
        friend SOAP_FMAC1 ns3__guid__ * SOAP_FMAC2 soap_instantiate_ns3__guid__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:559 */
#ifndef SOAP_TYPE_ns4__Side_
#define SOAP_TYPE_ns4__Side_ (101)
/* Type ns4__Side_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns4:Side': */
class SOAP_CMAC ns4__Side_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns4:Side' wrapped by this struct
        enum ns4__Side __item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Side_
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__Side_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Side_, default initialized and not managed by a soap context
        virtual ns4__Side_ *soap_alloc(void) const { return SOAP_NEW(ns4__Side_); }
      public:
        /// Constructor with initializations
        ns4__Side_()
        {
          __item = (enum ns4__Side)0;
        }
        virtual ~ns4__Side_() { }
        /// Friend allocator used by soap_new_ns4__Side_(struct soap*, int)
        friend SOAP_FMAC1 ns4__Side_ * SOAP_FMAC2 soap_instantiate_ns4__Side_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:345 */
#ifndef SOAP_TYPE__ns1__GetGloves
#define SOAP_TYPE__ns1__GetGloves (54)
/* complex XSD type 'ns1:GetGloves': */
class SOAP_CMAC _ns1__GetGloves {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetGloves
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetGloves; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetGloves, default initialized and not managed by a soap context
        virtual _ns1__GetGloves *soap_alloc(void) const { return SOAP_NEW(_ns1__GetGloves); }
      public:
        /// Constructor with initializations
        _ns1__GetGloves()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetGloves() { }
        /// Friend allocator used by soap_new__ns1__GetGloves(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetGloves * SOAP_FMAC2 soap_instantiate__ns1__GetGloves(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:348 */
#ifndef SOAP_TYPE__ns1__GetGlovesResponse
#define SOAP_TYPE__ns1__GetGlovesResponse (55)
/* complex XSD type 'ns1:GetGlovesResponse': */
class SOAP_CMAC _ns1__GetGlovesResponse {
      public:
        /// Optional element 'ns1:GetGlovesResult' of XSD type 'ns4:ArrayOfGlove'
        ns4__ArrayOfGlove *GetGlovesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetGlovesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetGlovesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetGlovesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetGlovesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetGlovesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetGlovesResponse()
        {
          GetGlovesResult = (ns4__ArrayOfGlove *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetGlovesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetGlovesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetGlovesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetGlovesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:351 */
#ifndef SOAP_TYPE__ns1__RefreshGloves
#define SOAP_TYPE__ns1__RefreshGloves (56)
/* complex XSD type 'ns1:RefreshGloves': */
class SOAP_CMAC _ns1__RefreshGloves {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RefreshGloves
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RefreshGloves; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RefreshGloves, default initialized and not managed by a soap context
        virtual _ns1__RefreshGloves *soap_alloc(void) const { return SOAP_NEW(_ns1__RefreshGloves); }
      public:
        /// Constructor with initializations
        _ns1__RefreshGloves()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RefreshGloves() { }
        /// Friend allocator used by soap_new__ns1__RefreshGloves(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RefreshGloves * SOAP_FMAC2 soap_instantiate__ns1__RefreshGloves(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:354 */
#ifndef SOAP_TYPE__ns1__RefreshGlovesResponse
#define SOAP_TYPE__ns1__RefreshGlovesResponse (57)
/* complex XSD type 'ns1:RefreshGlovesResponse': */
class SOAP_CMAC _ns1__RefreshGlovesResponse {
      public:
        /// Optional element 'ns1:RefreshGlovesResult' of XSD type 'ns4:ArrayOfGlove'
        ns4__ArrayOfGlove *RefreshGlovesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RefreshGlovesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RefreshGlovesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RefreshGlovesResponse, default initialized and not managed by a soap context
        virtual _ns1__RefreshGlovesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RefreshGlovesResponse); }
      public:
        /// Constructor with initializations
        _ns1__RefreshGlovesResponse()
        {
          RefreshGlovesResult = (ns4__ArrayOfGlove *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RefreshGlovesResponse() { }
        /// Friend allocator used by soap_new__ns1__RefreshGlovesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RefreshGlovesResponse * SOAP_FMAC2 soap_instantiate__ns1__RefreshGlovesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:357 */
#ifndef SOAP_TYPE__ns1__SaveGlove
#define SOAP_TYPE__ns1__SaveGlove (58)
/* complex XSD type 'ns1:SaveGlove': */
class SOAP_CMAC _ns1__SaveGlove {
      public:
        /// Optional element 'ns1:glove' of XSD type 'ns4:Glove'
        ns4__Glove *glove;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SaveGlove
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SaveGlove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SaveGlove, default initialized and not managed by a soap context
        virtual _ns1__SaveGlove *soap_alloc(void) const { return SOAP_NEW(_ns1__SaveGlove); }
      public:
        /// Constructor with initializations
        _ns1__SaveGlove()
        {
          glove = (ns4__Glove *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SaveGlove() { }
        /// Friend allocator used by soap_new__ns1__SaveGlove(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SaveGlove * SOAP_FMAC2 soap_instantiate__ns1__SaveGlove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:360 */
#ifndef SOAP_TYPE__ns1__SaveGloveResponse
#define SOAP_TYPE__ns1__SaveGloveResponse (59)
/* complex XSD type 'ns1:SaveGloveResponse': */
class SOAP_CMAC _ns1__SaveGloveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SaveGloveResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SaveGloveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SaveGloveResponse, default initialized and not managed by a soap context
        virtual _ns1__SaveGloveResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SaveGloveResponse); }
      public:
        /// Constructor with initializations
        _ns1__SaveGloveResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SaveGloveResponse() { }
        /// Friend allocator used by soap_new__ns1__SaveGloveResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SaveGloveResponse * SOAP_FMAC2 soap_instantiate__ns1__SaveGloveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:363 */
#ifndef SOAP_TYPE__ns1__Activate
#define SOAP_TYPE__ns1__Activate (60)
/* complex XSD type 'ns1:Activate': */
class SOAP_CMAC _ns1__Activate {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:actuator' of XSD type 'xsd:int'
        int *actuator;
        /// Optional element 'ns1:intensity' of XSD type 'xsd:int'
        int *intensity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Activate
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Activate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Activate, default initialized and not managed by a soap context
        virtual _ns1__Activate *soap_alloc(void) const { return SOAP_NEW(_ns1__Activate); }
      public:
        /// Constructor with initializations
        _ns1__Activate()
        {
          gloveAddress = (std::string *)0;
          actuator = (int *)0;
          intensity = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Activate() { }
        /// Friend allocator used by soap_new__ns1__Activate(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Activate * SOAP_FMAC2 soap_instantiate__ns1__Activate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:366 */
#ifndef SOAP_TYPE__ns1__ActivateResponse
#define SOAP_TYPE__ns1__ActivateResponse (61)
/* complex XSD type 'ns1:ActivateResponse': */
class SOAP_CMAC _ns1__ActivateResponse {
      public:
        /// Optional element 'ns1:ActivateResult' of XSD type 'xsd:int'
        int *ActivateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ActivateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ActivateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ActivateResponse, default initialized and not managed by a soap context
        virtual _ns1__ActivateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ActivateResponse); }
      public:
        /// Constructor with initializations
        _ns1__ActivateResponse()
        {
          ActivateResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ActivateResponse() { }
        /// Friend allocator used by soap_new__ns1__ActivateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ActivateResponse * SOAP_FMAC2 soap_instantiate__ns1__ActivateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:369 */
#ifndef SOAP_TYPE__ns1__Connect
#define SOAP_TYPE__ns1__Connect (62)
/* complex XSD type 'ns1:Connect': */
class SOAP_CMAC _ns1__Connect {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Connect
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Connect; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Connect, default initialized and not managed by a soap context
        virtual _ns1__Connect *soap_alloc(void) const { return SOAP_NEW(_ns1__Connect); }
      public:
        /// Constructor with initializations
        _ns1__Connect()
        {
          gloveAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Connect() { }
        /// Friend allocator used by soap_new__ns1__Connect(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Connect * SOAP_FMAC2 soap_instantiate__ns1__Connect(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:372 */
#ifndef SOAP_TYPE__ns1__ConnectResponse
#define SOAP_TYPE__ns1__ConnectResponse (63)
/* complex XSD type 'ns1:ConnectResponse': */
class SOAP_CMAC _ns1__ConnectResponse {
      public:
        /// Optional element 'ns1:ConnectResult' of XSD type 'xsd:int'
        int *ConnectResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ConnectResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ConnectResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ConnectResponse, default initialized and not managed by a soap context
        virtual _ns1__ConnectResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ConnectResponse); }
      public:
        /// Constructor with initializations
        _ns1__ConnectResponse()
        {
          ConnectResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ConnectResponse() { }
        /// Friend allocator used by soap_new__ns1__ConnectResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ConnectResponse * SOAP_FMAC2 soap_instantiate__ns1__ConnectResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:375 */
#ifndef SOAP_TYPE__ns1__Disconnect
#define SOAP_TYPE__ns1__Disconnect (64)
/* complex XSD type 'ns1:Disconnect': */
class SOAP_CMAC _ns1__Disconnect {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Disconnect
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Disconnect; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Disconnect, default initialized and not managed by a soap context
        virtual _ns1__Disconnect *soap_alloc(void) const { return SOAP_NEW(_ns1__Disconnect); }
      public:
        /// Constructor with initializations
        _ns1__Disconnect()
        {
          gloveAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Disconnect() { }
        /// Friend allocator used by soap_new__ns1__Disconnect(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Disconnect * SOAP_FMAC2 soap_instantiate__ns1__Disconnect(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:378 */
#ifndef SOAP_TYPE__ns1__DisconnectResponse
#define SOAP_TYPE__ns1__DisconnectResponse (65)
/* complex XSD type 'ns1:DisconnectResponse': */
class SOAP_CMAC _ns1__DisconnectResponse {
      public:
        /// Optional element 'ns1:DisconnectResult' of XSD type 'xsd:int'
        int *DisconnectResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DisconnectResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DisconnectResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DisconnectResponse, default initialized and not managed by a soap context
        virtual _ns1__DisconnectResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DisconnectResponse); }
      public:
        /// Constructor with initializations
        _ns1__DisconnectResponse()
        {
          DisconnectResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DisconnectResponse() { }
        /// Friend allocator used by soap_new__ns1__DisconnectResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DisconnectResponse * SOAP_FMAC2 soap_instantiate__ns1__DisconnectResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:381 */
#ifndef SOAP_TYPE__ns1__ActivateMany
#define SOAP_TYPE__ns1__ActivateMany (66)
/* complex XSD type 'ns1:ActivateMany': */
class SOAP_CMAC _ns1__ActivateMany {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:actuators' of XSD type 'ns5:ArrayOfint'
        ns5__ArrayOfint *actuators;
        /// Optional element 'ns1:intensityList' of XSD type 'ns5:ArrayOfint'
        ns5__ArrayOfint *intensityList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ActivateMany
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ActivateMany; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ActivateMany, default initialized and not managed by a soap context
        virtual _ns1__ActivateMany *soap_alloc(void) const { return SOAP_NEW(_ns1__ActivateMany); }
      public:
        /// Constructor with initializations
        _ns1__ActivateMany()
        {
          gloveAddress = (std::string *)0;
          actuators = (ns5__ArrayOfint *)0;
          intensityList = (ns5__ArrayOfint *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ActivateMany() { }
        /// Friend allocator used by soap_new__ns1__ActivateMany(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ActivateMany * SOAP_FMAC2 soap_instantiate__ns1__ActivateMany(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:384 */
#ifndef SOAP_TYPE__ns1__ActivateManyResponse
#define SOAP_TYPE__ns1__ActivateManyResponse (67)
/* complex XSD type 'ns1:ActivateManyResponse': */
class SOAP_CMAC _ns1__ActivateManyResponse {
      public:
        /// Optional element 'ns1:ActivateManyResult' of XSD type 'xsd:int'
        int *ActivateManyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ActivateManyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ActivateManyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ActivateManyResponse, default initialized and not managed by a soap context
        virtual _ns1__ActivateManyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ActivateManyResponse); }
      public:
        /// Constructor with initializations
        _ns1__ActivateManyResponse()
        {
          ActivateManyResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ActivateManyResponse() { }
        /// Friend allocator used by soap_new__ns1__ActivateManyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ActivateManyResponse * SOAP_FMAC2 soap_instantiate__ns1__ActivateManyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:387 */
#ifndef SOAP_TYPE__ns1__addFlexor
#define SOAP_TYPE__ns1__addFlexor (68)
/* complex XSD type 'ns1:addFlexor': */
class SOAP_CMAC _ns1__addFlexor {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:pin' of XSD type 'xsd:int'
        int *pin;
        /// Optional element 'ns1:mapping' of XSD type 'xsd:int'
        int *mapping;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__addFlexor
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__addFlexor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__addFlexor, default initialized and not managed by a soap context
        virtual _ns1__addFlexor *soap_alloc(void) const { return SOAP_NEW(_ns1__addFlexor); }
      public:
        /// Constructor with initializations
        _ns1__addFlexor()
        {
          gloveAddress = (std::string *)0;
          pin = (int *)0;
          mapping = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__addFlexor() { }
        /// Friend allocator used by soap_new__ns1__addFlexor(struct soap*, int)
        friend SOAP_FMAC1 _ns1__addFlexor * SOAP_FMAC2 soap_instantiate__ns1__addFlexor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:390 */
#ifndef SOAP_TYPE__ns1__addFlexorResponse
#define SOAP_TYPE__ns1__addFlexorResponse (69)
/* complex XSD type 'ns1:addFlexorResponse': */
class SOAP_CMAC _ns1__addFlexorResponse {
      public:
        /// Optional element 'ns1:addFlexorResult' of XSD type 'xsd:int'
        int *addFlexorResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__addFlexorResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__addFlexorResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__addFlexorResponse, default initialized and not managed by a soap context
        virtual _ns1__addFlexorResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__addFlexorResponse); }
      public:
        /// Constructor with initializations
        _ns1__addFlexorResponse()
        {
          addFlexorResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__addFlexorResponse() { }
        /// Friend allocator used by soap_new__ns1__addFlexorResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__addFlexorResponse * SOAP_FMAC2 soap_instantiate__ns1__addFlexorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:393 */
#ifndef SOAP_TYPE__ns1__removeFlexor
#define SOAP_TYPE__ns1__removeFlexor (70)
/* complex XSD type 'ns1:removeFlexor': */
class SOAP_CMAC _ns1__removeFlexor {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:mapping' of XSD type 'xsd:int'
        int *mapping;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__removeFlexor
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__removeFlexor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__removeFlexor, default initialized and not managed by a soap context
        virtual _ns1__removeFlexor *soap_alloc(void) const { return SOAP_NEW(_ns1__removeFlexor); }
      public:
        /// Constructor with initializations
        _ns1__removeFlexor()
        {
          gloveAddress = (std::string *)0;
          mapping = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__removeFlexor() { }
        /// Friend allocator used by soap_new__ns1__removeFlexor(struct soap*, int)
        friend SOAP_FMAC1 _ns1__removeFlexor * SOAP_FMAC2 soap_instantiate__ns1__removeFlexor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:396 */
#ifndef SOAP_TYPE__ns1__removeFlexorResponse
#define SOAP_TYPE__ns1__removeFlexorResponse (71)
/* complex XSD type 'ns1:removeFlexorResponse': */
class SOAP_CMAC _ns1__removeFlexorResponse {
      public:
        /// Optional element 'ns1:removeFlexorResult' of XSD type 'xsd:int'
        int *removeFlexorResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__removeFlexorResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__removeFlexorResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__removeFlexorResponse, default initialized and not managed by a soap context
        virtual _ns1__removeFlexorResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__removeFlexorResponse); }
      public:
        /// Constructor with initializations
        _ns1__removeFlexorResponse()
        {
          removeFlexorResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__removeFlexorResponse() { }
        /// Friend allocator used by soap_new__ns1__removeFlexorResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__removeFlexorResponse * SOAP_FMAC2 soap_instantiate__ns1__removeFlexorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:399 */
#ifndef SOAP_TYPE__ns1__calibrateFlexors
#define SOAP_TYPE__ns1__calibrateFlexors (72)
/* complex XSD type 'ns1:calibrateFlexors': */
class SOAP_CMAC _ns1__calibrateFlexors {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__calibrateFlexors
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__calibrateFlexors; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__calibrateFlexors, default initialized and not managed by a soap context
        virtual _ns1__calibrateFlexors *soap_alloc(void) const { return SOAP_NEW(_ns1__calibrateFlexors); }
      public:
        /// Constructor with initializations
        _ns1__calibrateFlexors()
        {
          gloveAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__calibrateFlexors() { }
        /// Friend allocator used by soap_new__ns1__calibrateFlexors(struct soap*, int)
        friend SOAP_FMAC1 _ns1__calibrateFlexors * SOAP_FMAC2 soap_instantiate__ns1__calibrateFlexors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:402 */
#ifndef SOAP_TYPE__ns1__calibrateFlexorsResponse
#define SOAP_TYPE__ns1__calibrateFlexorsResponse (73)
/* complex XSD type 'ns1:calibrateFlexorsResponse': */
class SOAP_CMAC _ns1__calibrateFlexorsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__calibrateFlexorsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__calibrateFlexorsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__calibrateFlexorsResponse, default initialized and not managed by a soap context
        virtual _ns1__calibrateFlexorsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__calibrateFlexorsResponse); }
      public:
        /// Constructor with initializations
        _ns1__calibrateFlexorsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__calibrateFlexorsResponse() { }
        /// Friend allocator used by soap_new__ns1__calibrateFlexorsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__calibrateFlexorsResponse * SOAP_FMAC2 soap_instantiate__ns1__calibrateFlexorsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:405 */
#ifndef SOAP_TYPE__ns1__confirmCalibration
#define SOAP_TYPE__ns1__confirmCalibration (74)
/* complex XSD type 'ns1:confirmCalibration': */
class SOAP_CMAC _ns1__confirmCalibration {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__confirmCalibration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__confirmCalibration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__confirmCalibration, default initialized and not managed by a soap context
        virtual _ns1__confirmCalibration *soap_alloc(void) const { return SOAP_NEW(_ns1__confirmCalibration); }
      public:
        /// Constructor with initializations
        _ns1__confirmCalibration()
        {
          gloveAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__confirmCalibration() { }
        /// Friend allocator used by soap_new__ns1__confirmCalibration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__confirmCalibration * SOAP_FMAC2 soap_instantiate__ns1__confirmCalibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:408 */
#ifndef SOAP_TYPE__ns1__confirmCalibrationResponse
#define SOAP_TYPE__ns1__confirmCalibrationResponse (75)
/* complex XSD type 'ns1:confirmCalibrationResponse': */
class SOAP_CMAC _ns1__confirmCalibrationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__confirmCalibrationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__confirmCalibrationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__confirmCalibrationResponse, default initialized and not managed by a soap context
        virtual _ns1__confirmCalibrationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__confirmCalibrationResponse); }
      public:
        /// Constructor with initializations
        _ns1__confirmCalibrationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__confirmCalibrationResponse() { }
        /// Friend allocator used by soap_new__ns1__confirmCalibrationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__confirmCalibrationResponse * SOAP_FMAC2 soap_instantiate__ns1__confirmCalibrationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:411 */
#ifndef SOAP_TYPE__ns1__setThreshold
#define SOAP_TYPE__ns1__setThreshold (76)
/* complex XSD type 'ns1:setThreshold': */
class SOAP_CMAC _ns1__setThreshold {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:value' of XSD type 'xsd:int'
        int *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setThreshold
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setThreshold; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setThreshold, default initialized and not managed by a soap context
        virtual _ns1__setThreshold *soap_alloc(void) const { return SOAP_NEW(_ns1__setThreshold); }
      public:
        /// Constructor with initializations
        _ns1__setThreshold()
        {
          gloveAddress = (std::string *)0;
          value = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__setThreshold() { }
        /// Friend allocator used by soap_new__ns1__setThreshold(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setThreshold * SOAP_FMAC2 soap_instantiate__ns1__setThreshold(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:414 */
#ifndef SOAP_TYPE__ns1__setThresholdResponse
#define SOAP_TYPE__ns1__setThresholdResponse (77)
/* complex XSD type 'ns1:setThresholdResponse': */
class SOAP_CMAC _ns1__setThresholdResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setThresholdResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setThresholdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setThresholdResponse, default initialized and not managed by a soap context
        virtual _ns1__setThresholdResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__setThresholdResponse); }
      public:
        /// Constructor with initializations
        _ns1__setThresholdResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__setThresholdResponse() { }
        /// Friend allocator used by soap_new__ns1__setThresholdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setThresholdResponse * SOAP_FMAC2 soap_instantiate__ns1__setThresholdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:417 */
#ifndef SOAP_TYPE__ns1__resetFlexors
#define SOAP_TYPE__ns1__resetFlexors (78)
/* complex XSD type 'ns1:resetFlexors': */
class SOAP_CMAC _ns1__resetFlexors {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__resetFlexors
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__resetFlexors; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__resetFlexors, default initialized and not managed by a soap context
        virtual _ns1__resetFlexors *soap_alloc(void) const { return SOAP_NEW(_ns1__resetFlexors); }
      public:
        /// Constructor with initializations
        _ns1__resetFlexors()
        {
          gloveAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__resetFlexors() { }
        /// Friend allocator used by soap_new__ns1__resetFlexors(struct soap*, int)
        friend SOAP_FMAC1 _ns1__resetFlexors * SOAP_FMAC2 soap_instantiate__ns1__resetFlexors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:420 */
#ifndef SOAP_TYPE__ns1__resetFlexorsResponse
#define SOAP_TYPE__ns1__resetFlexorsResponse (79)
/* complex XSD type 'ns1:resetFlexorsResponse': */
class SOAP_CMAC _ns1__resetFlexorsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__resetFlexorsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__resetFlexorsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__resetFlexorsResponse, default initialized and not managed by a soap context
        virtual _ns1__resetFlexorsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__resetFlexorsResponse); }
      public:
        /// Constructor with initializations
        _ns1__resetFlexorsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__resetFlexorsResponse() { }
        /// Friend allocator used by soap_new__ns1__resetFlexorsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__resetFlexorsResponse * SOAP_FMAC2 soap_instantiate__ns1__resetFlexorsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:423 */
#ifndef SOAP_TYPE__ns1__startIMU
#define SOAP_TYPE__ns1__startIMU (80)
/* complex XSD type 'ns1:startIMU': */
class SOAP_CMAC _ns1__startIMU {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__startIMU
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__startIMU; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__startIMU, default initialized and not managed by a soap context
        virtual _ns1__startIMU *soap_alloc(void) const { return SOAP_NEW(_ns1__startIMU); }
      public:
        /// Constructor with initializations
        _ns1__startIMU()
        {
          gloveAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__startIMU() { }
        /// Friend allocator used by soap_new__ns1__startIMU(struct soap*, int)
        friend SOAP_FMAC1 _ns1__startIMU * SOAP_FMAC2 soap_instantiate__ns1__startIMU(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:426 */
#ifndef SOAP_TYPE__ns1__startIMUResponse
#define SOAP_TYPE__ns1__startIMUResponse (81)
/* complex XSD type 'ns1:startIMUResponse': */
class SOAP_CMAC _ns1__startIMUResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__startIMUResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__startIMUResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__startIMUResponse, default initialized and not managed by a soap context
        virtual _ns1__startIMUResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__startIMUResponse); }
      public:
        /// Constructor with initializations
        _ns1__startIMUResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__startIMUResponse() { }
        /// Friend allocator used by soap_new__ns1__startIMUResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__startIMUResponse * SOAP_FMAC2 soap_instantiate__ns1__startIMUResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:429 */
#ifndef SOAP_TYPE__ns1__setIMUStatus
#define SOAP_TYPE__ns1__setIMUStatus (82)
/* complex XSD type 'ns1:setIMUStatus': */
class SOAP_CMAC _ns1__setIMUStatus {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:value' of XSD type 'xsd:int'
        int *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setIMUStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setIMUStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setIMUStatus, default initialized and not managed by a soap context
        virtual _ns1__setIMUStatus *soap_alloc(void) const { return SOAP_NEW(_ns1__setIMUStatus); }
      public:
        /// Constructor with initializations
        _ns1__setIMUStatus()
        {
          gloveAddress = (std::string *)0;
          value = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__setIMUStatus() { }
        /// Friend allocator used by soap_new__ns1__setIMUStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setIMUStatus * SOAP_FMAC2 soap_instantiate__ns1__setIMUStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:432 */
#ifndef SOAP_TYPE__ns1__setIMUStatusResponse
#define SOAP_TYPE__ns1__setIMUStatusResponse (83)
/* complex XSD type 'ns1:setIMUStatusResponse': */
class SOAP_CMAC _ns1__setIMUStatusResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setIMUStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setIMUStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setIMUStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__setIMUStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__setIMUStatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__setIMUStatusResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__setIMUStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__setIMUStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setIMUStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__setIMUStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:435 */
#ifndef SOAP_TYPE__ns1__setRawData
#define SOAP_TYPE__ns1__setRawData (84)
/* complex XSD type 'ns1:setRawData': */
class SOAP_CMAC _ns1__setRawData {
      public:
        /// Optional element 'ns1:gloveAddress' of XSD type 'xsd:string'
        std::string *gloveAddress;
        /// Optional element 'ns1:value' of XSD type 'xsd:int'
        int *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setRawData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setRawData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setRawData, default initialized and not managed by a soap context
        virtual _ns1__setRawData *soap_alloc(void) const { return SOAP_NEW(_ns1__setRawData); }
      public:
        /// Constructor with initializations
        _ns1__setRawData()
        {
          gloveAddress = (std::string *)0;
          value = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__setRawData() { }
        /// Friend allocator used by soap_new__ns1__setRawData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setRawData * SOAP_FMAC2 soap_instantiate__ns1__setRawData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:438 */
#ifndef SOAP_TYPE__ns1__setRawDataResponse
#define SOAP_TYPE__ns1__setRawDataResponse (85)
/* complex XSD type 'ns1:setRawDataResponse': */
class SOAP_CMAC _ns1__setRawDataResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setRawDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setRawDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setRawDataResponse, default initialized and not managed by a soap context
        virtual _ns1__setRawDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__setRawDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__setRawDataResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__setRawDataResponse() { }
        /// Friend allocator used by soap_new__ns1__setRawDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setRawDataResponse * SOAP_FMAC2 soap_instantiate__ns1__setRawDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:441 */
#ifndef SOAP_TYPE_ns4__ArrayOfGlove
#define SOAP_TYPE_ns4__ArrayOfGlove (86)
/* Type ns4__ArrayOfGlove is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns4:ArrayOfGlove': */
class SOAP_CMAC ns4__ArrayOfGlove : public xsd__anyType {
      public:
        /// Optional element 'ns4:Glove' of XSD type 'ns4:Glove'
        std::vector<ns4__Glove *> Glove;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfGlove
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfGlove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfGlove, default initialized and not managed by a soap context
        virtual ns4__ArrayOfGlove *soap_alloc(void) const { return SOAP_NEW(ns4__ArrayOfGlove); }
      public:
        /// Constructor with initializations
        ns4__ArrayOfGlove()
        {
        }
        virtual ~ns4__ArrayOfGlove() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfGlove(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfGlove * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfGlove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:444 */
#ifndef SOAP_TYPE_ns4__Glove
#define SOAP_TYPE_ns4__Glove (87)
/* Type ns4__Glove is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns4:Glove': */
class SOAP_CMAC ns4__Glove : public xsd__anyType {
      public:
        /// Optional element 'ns4:BluetoothAddress' of XSD type 'xsd:string'
        std::string *BluetoothAddress;
        /// Optional element 'ns4:Connected' of XSD type 'xsd:boolean'
        bool *Connected;
        /// Optional element 'ns4:GloveConfiguration' of XSD type 'ns4:Glove.Configuration'
        ns4__Glove_x002eConfiguration *GloveConfiguration;
        /// Optional element 'ns4:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns4:Port' of XSD type 'xsd:string'
        std::string *Port;
        /// Optional element 'ns4:Side' of XSD type 'ns4:Side'
        enum ns4__Side *Side;
        /// Optional element 'ns4:WebSocketPort' of XSD type 'xsd:string'
        std::string *WebSocketPort;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Glove
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__Glove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Glove, default initialized and not managed by a soap context
        virtual ns4__Glove *soap_alloc(void) const { return SOAP_NEW(ns4__Glove); }
      public:
        /// Constructor with initializations
        ns4__Glove()
        {
          BluetoothAddress = (std::string *)0;
          Connected = (bool *)0;
          GloveConfiguration = (ns4__Glove_x002eConfiguration *)0;
          Name = (std::string *)0;
          Port = (std::string *)0;
          Side = (enum ns4__Side *)0;
          WebSocketPort = (std::string *)0;
        }
        virtual ~ns4__Glove() { }
        /// Friend allocator used by soap_new_ns4__Glove(struct soap*, int)
        friend SOAP_FMAC1 ns4__Glove * SOAP_FMAC2 soap_instantiate_ns4__Glove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:447 */
#ifndef SOAP_TYPE_ns4__Glove_x002eConfiguration
#define SOAP_TYPE_ns4__Glove_x002eConfiguration (88)
/* Type ns4__Glove_x002eConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns4:Glove.Configuration': */
class SOAP_CMAC ns4__Glove_x002eConfiguration : public xsd__anyType {
      public:
        /// Optional element 'ns4:AllowedBaudRates' of XSD type 'ns5:ArrayOfint'
        ns5__ArrayOfint *AllowedBaudRates;
        /// Optional element 'ns4:BaudRate' of XSD type 'xsd:int'
        int *BaudRate;
        /// Optional element 'ns4:FlexInit' of XSD type 'ns5:ArrayOfstring'
        ns5__ArrayOfstring *FlexInit;
        /// Optional element 'ns4:FlexPins' of XSD type 'ns5:ArrayOfint'
        ns5__ArrayOfint *FlexPins;
        /// Optional element 'ns4:GloveHash' of XSD type 'xsd:string'
        std::string *GloveHash;
        /// Optional element 'ns4:GloveName' of XSD type 'xsd:string'
        std::string *GloveName;
        /// Optional element 'ns4:GloveProfile' of XSD type 'ns4:Glove.Configuration.Profile'
        ns4__Glove_x002eConfiguration_x002eProfile *GloveProfile;
        /// Optional element 'ns4:NegativeInit' of XSD type 'ns5:ArrayOfstring'
        ns5__ArrayOfstring *NegativeInit;
        /// Optional element 'ns4:NegativePins' of XSD type 'ns5:ArrayOfint'
        ns5__ArrayOfint *NegativePins;
        /// Optional element 'ns4:PositiveInit' of XSD type 'ns5:ArrayOfstring'
        ns5__ArrayOfstring *PositiveInit;
        /// Optional element 'ns4:PositivePins' of XSD type 'ns5:ArrayOfint'
        ns5__ArrayOfint *PositivePins;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Glove_x002eConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__Glove_x002eConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Glove_x002eConfiguration, default initialized and not managed by a soap context
        virtual ns4__Glove_x002eConfiguration *soap_alloc(void) const { return SOAP_NEW(ns4__Glove_x002eConfiguration); }
      public:
        /// Constructor with initializations
        ns4__Glove_x002eConfiguration()
        {
          AllowedBaudRates = (ns5__ArrayOfint *)0;
          BaudRate = (int *)0;
          FlexInit = (ns5__ArrayOfstring *)0;
          FlexPins = (ns5__ArrayOfint *)0;
          GloveHash = (std::string *)0;
          GloveName = (std::string *)0;
          GloveProfile = (ns4__Glove_x002eConfiguration_x002eProfile *)0;
          NegativeInit = (ns5__ArrayOfstring *)0;
          NegativePins = (ns5__ArrayOfint *)0;
          PositiveInit = (ns5__ArrayOfstring *)0;
          PositivePins = (ns5__ArrayOfint *)0;
        }
        virtual ~ns4__Glove_x002eConfiguration() { }
        /// Friend allocator used by soap_new_ns4__Glove_x002eConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns4__Glove_x002eConfiguration * SOAP_FMAC2 soap_instantiate_ns4__Glove_x002eConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:450 */
#ifndef SOAP_TYPE_ns4__Glove_x002eConfiguration_x002eProfile
#define SOAP_TYPE_ns4__Glove_x002eConfiguration_x002eProfile (89)
/* Type ns4__Glove_x002eConfiguration_x002eProfile is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns4:Glove.Configuration.Profile': */
class SOAP_CMAC ns4__Glove_x002eConfiguration_x002eProfile : public xsd__anyType {
      public:
        /// Optional element 'ns4:AreaCount' of XSD type 'xsd:int'
        int *AreaCount;
        /// Optional element 'ns4:FlexorsMappings' of XSD type 'ns5:ArrayOfKeyValueOfintint'
        ns5__ArrayOfKeyValueOfintint *FlexorsMappings;
        /// Optional element 'ns4:FlexorsThreshold' of XSD type 'xsd:int'
        int *FlexorsThreshold;
        /// Optional element 'ns4:GloveHash' of XSD type 'xsd:string'
        std::string *GloveHash;
        /// Optional element 'ns4:Mappings' of XSD type 'ns5:ArrayOfKeyValueOfstringstring'
        ns5__ArrayOfKeyValueOfstringstring *Mappings;
        /// Optional element 'ns4:ProfileName' of XSD type 'xsd:string'
        std::string *ProfileName;
        /// Optional element 'ns4:imuCalibrationStatus' of XSD type 'xsd:boolean'
        bool *imuCalibrationStatus;
        /// Optional element 'ns4:imuModel' of XSD type 'xsd:string'
        std::string *imuModel;
        /// Optional element 'ns4:imuStatus' of XSD type 'xsd:boolean'
        bool *imuStatus;
        /// Optional element 'ns4:rawData' of XSD type 'xsd:boolean'
        bool *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Glove_x002eConfiguration_x002eProfile
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__Glove_x002eConfiguration_x002eProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Glove_x002eConfiguration_x002eProfile, default initialized and not managed by a soap context
        virtual ns4__Glove_x002eConfiguration_x002eProfile *soap_alloc(void) const { return SOAP_NEW(ns4__Glove_x002eConfiguration_x002eProfile); }
      public:
        /// Constructor with initializations
        ns4__Glove_x002eConfiguration_x002eProfile()
        {
          AreaCount = (int *)0;
          FlexorsMappings = (ns5__ArrayOfKeyValueOfintint *)0;
          FlexorsThreshold = (int *)0;
          GloveHash = (std::string *)0;
          Mappings = (ns5__ArrayOfKeyValueOfstringstring *)0;
          ProfileName = (std::string *)0;
          imuCalibrationStatus = (bool *)0;
          imuModel = (std::string *)0;
          imuStatus = (bool *)0;
          rawData = (bool *)0;
        }
        virtual ~ns4__Glove_x002eConfiguration_x002eProfile() { }
        /// Friend allocator used by soap_new_ns4__Glove_x002eConfiguration_x002eProfile(struct soap*, int)
        friend SOAP_FMAC1 ns4__Glove_x002eConfiguration_x002eProfile * SOAP_FMAC2 soap_instantiate_ns4__Glove_x002eConfiguration_x002eProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:453 */
#ifndef SOAP_TYPE_ns5__ArrayOfint
#define SOAP_TYPE_ns5__ArrayOfint (90)
/* Type ns5__ArrayOfint is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ArrayOfint': */
class SOAP_CMAC ns5__ArrayOfint : public xsd__anyType {
      public:
        /// Optional element 'ns5:int' of XSD type 'xsd:int'
        std::vector<int> int_;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ArrayOfint
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__ArrayOfint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ArrayOfint, default initialized and not managed by a soap context
        virtual ns5__ArrayOfint *soap_alloc(void) const { return SOAP_NEW(ns5__ArrayOfint); }
      public:
        /// Constructor with initializations
        ns5__ArrayOfint()
        {
        }
        virtual ~ns5__ArrayOfint() { }
        /// Friend allocator used by soap_new_ns5__ArrayOfint(struct soap*, int)
        friend SOAP_FMAC1 ns5__ArrayOfint * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:456 */
#ifndef SOAP_TYPE_ns5__ArrayOfstring
#define SOAP_TYPE_ns5__ArrayOfstring (91)
/* Type ns5__ArrayOfstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ArrayOfstring': */
class SOAP_CMAC ns5__ArrayOfstring : public xsd__anyType {
      public:
        /// Optional element 'ns5:string' of XSD type 'xsd:string'
        std::vector<std::string> string;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ArrayOfstring
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ArrayOfstring, default initialized and not managed by a soap context
        virtual ns5__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW(ns5__ArrayOfstring); }
      public:
        /// Constructor with initializations
        ns5__ArrayOfstring()
        {
        }
        virtual ~ns5__ArrayOfstring() { }
        /// Friend allocator used by soap_new_ns5__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 ns5__ArrayOfstring * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:1468 */
#ifndef SOAP_TYPE__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint
#define SOAP_TYPE__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint (117)
/* complex XSD type 'ns5:ArrayOfKeyValueOfintint-KeyValueOfintint': */
class SOAP_CMAC _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint {
      public:
        /// Required element 'ns5:Key' of XSD type 'xsd:int'
        int Key;
        /// Required element 'ns5:Value' of XSD type 'xsd:int'
        int Value;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint
        virtual int soap_type(void) const { return SOAP_TYPE__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint, default initialized and not managed by a soap context
        virtual _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint *soap_alloc(void) const { return SOAP_NEW(_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint); }
      public:
        /// Constructor with initializations
        _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint()
        {
          Key = (int)0;
          Value = (int)0;
        }
        virtual ~_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint() { }
        /// Friend allocator used by soap_new__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint * SOAP_FMAC2 soap_instantiate__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:459 */
#ifndef SOAP_TYPE_ns5__ArrayOfKeyValueOfintint
#define SOAP_TYPE_ns5__ArrayOfKeyValueOfintint (92)
/* Type ns5__ArrayOfKeyValueOfintint is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ArrayOfKeyValueOfintint': */
class SOAP_CMAC ns5__ArrayOfKeyValueOfintint : public xsd__anyType {
      public:
        /// Optional element 'ns5:KeyValueOfintint' of XSD type 'ns5:ArrayOfKeyValueOfintint-KeyValueOfintint'
        std::vector<_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint> *KeyValueOfintint;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ArrayOfKeyValueOfintint
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__ArrayOfKeyValueOfintint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ArrayOfKeyValueOfintint, default initialized and not managed by a soap context
        virtual ns5__ArrayOfKeyValueOfintint *soap_alloc(void) const { return SOAP_NEW(ns5__ArrayOfKeyValueOfintint); }
      public:
        /// Constructor with initializations
        ns5__ArrayOfKeyValueOfintint()
        {
          KeyValueOfintint = (std::vector<_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint> *)0;
        }
        virtual ~ns5__ArrayOfKeyValueOfintint() { }
        /// Friend allocator used by soap_new_ns5__ArrayOfKeyValueOfintint(struct soap*, int)
        friend SOAP_FMAC1 ns5__ArrayOfKeyValueOfintint * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfKeyValueOfintint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:1503 */
#ifndef SOAP_TYPE__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (120)
/* complex XSD type 'ns5:ArrayOfKeyValueOfstringstring-KeyValueOfstringstring': */
class SOAP_CMAC _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring {
      public:
        /// Required element 'ns5:Key' of XSD type 'xsd:string'
        std::string *Key;
        /// Required element 'ns5:Value' of XSD type 'xsd:string'
        std::string *Value;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
        virtual int soap_type(void) const { return SOAP_TYPE__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring, default initialized and not managed by a soap context
        virtual _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring *soap_alloc(void) const { return SOAP_NEW(_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring); }
      public:
        /// Constructor with initializations
        _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring()
        {
          Key = (std::string *)0;
          Value = (std::string *)0;
        }
        virtual ~_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring() { }
        /// Friend allocator used by soap_new__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring * SOAP_FMAC2 soap_instantiate__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:462 */
#ifndef SOAP_TYPE_ns5__ArrayOfKeyValueOfstringstring
#define SOAP_TYPE_ns5__ArrayOfKeyValueOfstringstring (93)
/* Type ns5__ArrayOfKeyValueOfstringstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ArrayOfKeyValueOfstringstring': */
class SOAP_CMAC ns5__ArrayOfKeyValueOfstringstring : public xsd__anyType {
      public:
        /// Optional element 'ns5:KeyValueOfstringstring' of XSD type 'ns5:ArrayOfKeyValueOfstringstring-KeyValueOfstringstring'
        std::vector<_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring> *KeyValueOfstringstring;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ArrayOfKeyValueOfstringstring
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__ArrayOfKeyValueOfstringstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ArrayOfKeyValueOfstringstring, default initialized and not managed by a soap context
        virtual ns5__ArrayOfKeyValueOfstringstring *soap_alloc(void) const { return SOAP_NEW(ns5__ArrayOfKeyValueOfstringstring); }
      public:
        /// Constructor with initializations
        ns5__ArrayOfKeyValueOfstringstring()
        {
          KeyValueOfstringstring = (std::vector<_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring> *)0;
        }
        virtual ~ns5__ArrayOfKeyValueOfstringstring() { }
        /// Friend allocator used by soap_new_ns5__ArrayOfKeyValueOfstringstring(struct soap*, int)
        friend SOAP_FMAC1 ns5__ArrayOfKeyValueOfstringstring * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfKeyValueOfstringstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:1849 */
#ifndef SOAP_TYPE___ns1__GetGloves
#define SOAP_TYPE___ns1__GetGloves (126)
/* Wrapper: */
struct __ns1__GetGloves {
      public:
        /** Optional element 'ns1:GetGloves' of XSD type 'ns1:GetGloves' */
        _ns1__GetGloves *ns1__GetGloves;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetGloves */
        int soap_type() const { return SOAP_TYPE___ns1__GetGloves; }
        /** Constructor with member initializations */
        __ns1__GetGloves()
        {
          ns1__GetGloves = (_ns1__GetGloves *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetGloves(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetGloves * SOAP_FMAC2 soap_instantiate___ns1__GetGloves(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:1919 */
#ifndef SOAP_TYPE___ns1__RefreshGloves
#define SOAP_TYPE___ns1__RefreshGloves (130)
/* Wrapper: */
struct __ns1__RefreshGloves {
      public:
        /** Optional element 'ns1:RefreshGloves' of XSD type 'ns1:RefreshGloves' */
        _ns1__RefreshGloves *ns1__RefreshGloves;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RefreshGloves */
        int soap_type() const { return SOAP_TYPE___ns1__RefreshGloves; }
        /** Constructor with member initializations */
        __ns1__RefreshGloves()
        {
          ns1__RefreshGloves = (_ns1__RefreshGloves *)0;
        }
        /** Friend allocator used by soap_new___ns1__RefreshGloves(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RefreshGloves * SOAP_FMAC2 soap_instantiate___ns1__RefreshGloves(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:1989 */
#ifndef SOAP_TYPE___ns1__SaveGlove
#define SOAP_TYPE___ns1__SaveGlove (134)
/* Wrapper: */
struct __ns1__SaveGlove {
      public:
        /** Optional element 'ns1:SaveGlove' of XSD type 'ns1:SaveGlove' */
        _ns1__SaveGlove *ns1__SaveGlove;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SaveGlove */
        int soap_type() const { return SOAP_TYPE___ns1__SaveGlove; }
        /** Constructor with member initializations */
        __ns1__SaveGlove()
        {
          ns1__SaveGlove = (_ns1__SaveGlove *)0;
        }
        /** Friend allocator used by soap_new___ns1__SaveGlove(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SaveGlove * SOAP_FMAC2 soap_instantiate___ns1__SaveGlove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2059 */
#ifndef SOAP_TYPE___ns1__Activate
#define SOAP_TYPE___ns1__Activate (138)
/* Wrapper: */
struct __ns1__Activate {
      public:
        /** Optional element 'ns1:Activate' of XSD type 'ns1:Activate' */
        _ns1__Activate *ns1__Activate;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Activate */
        int soap_type() const { return SOAP_TYPE___ns1__Activate; }
        /** Constructor with member initializations */
        __ns1__Activate()
        {
          ns1__Activate = (_ns1__Activate *)0;
        }
        /** Friend allocator used by soap_new___ns1__Activate(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Activate * SOAP_FMAC2 soap_instantiate___ns1__Activate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2129 */
#ifndef SOAP_TYPE___ns1__Connect
#define SOAP_TYPE___ns1__Connect (142)
/* Wrapper: */
struct __ns1__Connect {
      public:
        /** Optional element 'ns1:Connect' of XSD type 'ns1:Connect' */
        _ns1__Connect *ns1__Connect;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Connect */
        int soap_type() const { return SOAP_TYPE___ns1__Connect; }
        /** Constructor with member initializations */
        __ns1__Connect()
        {
          ns1__Connect = (_ns1__Connect *)0;
        }
        /** Friend allocator used by soap_new___ns1__Connect(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Connect * SOAP_FMAC2 soap_instantiate___ns1__Connect(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2199 */
#ifndef SOAP_TYPE___ns1__Disconnect
#define SOAP_TYPE___ns1__Disconnect (146)
/* Wrapper: */
struct __ns1__Disconnect {
      public:
        /** Optional element 'ns1:Disconnect' of XSD type 'ns1:Disconnect' */
        _ns1__Disconnect *ns1__Disconnect;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Disconnect */
        int soap_type() const { return SOAP_TYPE___ns1__Disconnect; }
        /** Constructor with member initializations */
        __ns1__Disconnect()
        {
          ns1__Disconnect = (_ns1__Disconnect *)0;
        }
        /** Friend allocator used by soap_new___ns1__Disconnect(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Disconnect * SOAP_FMAC2 soap_instantiate___ns1__Disconnect(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2269 */
#ifndef SOAP_TYPE___ns1__ActivateMany
#define SOAP_TYPE___ns1__ActivateMany (150)
/* Wrapper: */
struct __ns1__ActivateMany {
      public:
        /** Optional element 'ns1:ActivateMany' of XSD type 'ns1:ActivateMany' */
        _ns1__ActivateMany *ns1__ActivateMany;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ActivateMany */
        int soap_type() const { return SOAP_TYPE___ns1__ActivateMany; }
        /** Constructor with member initializations */
        __ns1__ActivateMany()
        {
          ns1__ActivateMany = (_ns1__ActivateMany *)0;
        }
        /** Friend allocator used by soap_new___ns1__ActivateMany(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ActivateMany * SOAP_FMAC2 soap_instantiate___ns1__ActivateMany(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2339 */
#ifndef SOAP_TYPE___ns1__addFlexor
#define SOAP_TYPE___ns1__addFlexor (154)
/* Wrapper: */
struct __ns1__addFlexor {
      public:
        /** Optional element 'ns1:addFlexor' of XSD type 'ns1:addFlexor' */
        _ns1__addFlexor *ns1__addFlexor;
      public:
        /** Return unique type id SOAP_TYPE___ns1__addFlexor */
        int soap_type() const { return SOAP_TYPE___ns1__addFlexor; }
        /** Constructor with member initializations */
        __ns1__addFlexor()
        {
          ns1__addFlexor = (_ns1__addFlexor *)0;
        }
        /** Friend allocator used by soap_new___ns1__addFlexor(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__addFlexor * SOAP_FMAC2 soap_instantiate___ns1__addFlexor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2409 */
#ifndef SOAP_TYPE___ns1__removeFlexor
#define SOAP_TYPE___ns1__removeFlexor (158)
/* Wrapper: */
struct __ns1__removeFlexor {
      public:
        /** Optional element 'ns1:removeFlexor' of XSD type 'ns1:removeFlexor' */
        _ns1__removeFlexor *ns1__removeFlexor;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeFlexor */
        int soap_type() const { return SOAP_TYPE___ns1__removeFlexor; }
        /** Constructor with member initializations */
        __ns1__removeFlexor()
        {
          ns1__removeFlexor = (_ns1__removeFlexor *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeFlexor(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeFlexor * SOAP_FMAC2 soap_instantiate___ns1__removeFlexor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2479 */
#ifndef SOAP_TYPE___ns1__calibrateFlexors
#define SOAP_TYPE___ns1__calibrateFlexors (162)
/* Wrapper: */
struct __ns1__calibrateFlexors {
      public:
        /** Optional element 'ns1:calibrateFlexors' of XSD type 'ns1:calibrateFlexors' */
        _ns1__calibrateFlexors *ns1__calibrateFlexors;
      public:
        /** Return unique type id SOAP_TYPE___ns1__calibrateFlexors */
        int soap_type() const { return SOAP_TYPE___ns1__calibrateFlexors; }
        /** Constructor with member initializations */
        __ns1__calibrateFlexors()
        {
          ns1__calibrateFlexors = (_ns1__calibrateFlexors *)0;
        }
        /** Friend allocator used by soap_new___ns1__calibrateFlexors(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__calibrateFlexors * SOAP_FMAC2 soap_instantiate___ns1__calibrateFlexors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2549 */
#ifndef SOAP_TYPE___ns1__confirmCalibration
#define SOAP_TYPE___ns1__confirmCalibration (166)
/* Wrapper: */
struct __ns1__confirmCalibration {
      public:
        /** Optional element 'ns1:confirmCalibration' of XSD type 'ns1:confirmCalibration' */
        _ns1__confirmCalibration *ns1__confirmCalibration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__confirmCalibration */
        int soap_type() const { return SOAP_TYPE___ns1__confirmCalibration; }
        /** Constructor with member initializations */
        __ns1__confirmCalibration()
        {
          ns1__confirmCalibration = (_ns1__confirmCalibration *)0;
        }
        /** Friend allocator used by soap_new___ns1__confirmCalibration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__confirmCalibration * SOAP_FMAC2 soap_instantiate___ns1__confirmCalibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2619 */
#ifndef SOAP_TYPE___ns1__setThreshold
#define SOAP_TYPE___ns1__setThreshold (170)
/* Wrapper: */
struct __ns1__setThreshold {
      public:
        /** Optional element 'ns1:setThreshold' of XSD type 'ns1:setThreshold' */
        _ns1__setThreshold *ns1__setThreshold;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setThreshold */
        int soap_type() const { return SOAP_TYPE___ns1__setThreshold; }
        /** Constructor with member initializations */
        __ns1__setThreshold()
        {
          ns1__setThreshold = (_ns1__setThreshold *)0;
        }
        /** Friend allocator used by soap_new___ns1__setThreshold(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setThreshold * SOAP_FMAC2 soap_instantiate___ns1__setThreshold(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2689 */
#ifndef SOAP_TYPE___ns1__resetFlexors
#define SOAP_TYPE___ns1__resetFlexors (174)
/* Wrapper: */
struct __ns1__resetFlexors {
      public:
        /** Optional element 'ns1:resetFlexors' of XSD type 'ns1:resetFlexors' */
        _ns1__resetFlexors *ns1__resetFlexors;
      public:
        /** Return unique type id SOAP_TYPE___ns1__resetFlexors */
        int soap_type() const { return SOAP_TYPE___ns1__resetFlexors; }
        /** Constructor with member initializations */
        __ns1__resetFlexors()
        {
          ns1__resetFlexors = (_ns1__resetFlexors *)0;
        }
        /** Friend allocator used by soap_new___ns1__resetFlexors(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__resetFlexors * SOAP_FMAC2 soap_instantiate___ns1__resetFlexors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2759 */
#ifndef SOAP_TYPE___ns1__startIMU
#define SOAP_TYPE___ns1__startIMU (178)
/* Wrapper: */
struct __ns1__startIMU {
      public:
        /** Optional element 'ns1:startIMU' of XSD type 'ns1:startIMU' */
        _ns1__startIMU *ns1__startIMU;
      public:
        /** Return unique type id SOAP_TYPE___ns1__startIMU */
        int soap_type() const { return SOAP_TYPE___ns1__startIMU; }
        /** Constructor with member initializations */
        __ns1__startIMU()
        {
          ns1__startIMU = (_ns1__startIMU *)0;
        }
        /** Friend allocator used by soap_new___ns1__startIMU(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__startIMU * SOAP_FMAC2 soap_instantiate___ns1__startIMU(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2829 */
#ifndef SOAP_TYPE___ns1__setIMUStatus
#define SOAP_TYPE___ns1__setIMUStatus (182)
/* Wrapper: */
struct __ns1__setIMUStatus {
      public:
        /** Optional element 'ns1:setIMUStatus' of XSD type 'ns1:setIMUStatus' */
        _ns1__setIMUStatus *ns1__setIMUStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setIMUStatus */
        int soap_type() const { return SOAP_TYPE___ns1__setIMUStatus; }
        /** Constructor with member initializations */
        __ns1__setIMUStatus()
        {
          ns1__setIMUStatus = (_ns1__setIMUStatus *)0;
        }
        /** Friend allocator used by soap_new___ns1__setIMUStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setIMUStatus * SOAP_FMAC2 soap_instantiate___ns1__setIMUStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:2899 */
#ifndef SOAP_TYPE___ns1__setRawData
#define SOAP_TYPE___ns1__setRawData (186)
/* Wrapper: */
struct __ns1__setRawData {
      public:
        /** Optional element 'ns1:setRawData' of XSD type 'ns1:setRawData' */
        _ns1__setRawData *ns1__setRawData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setRawData */
        int soap_type() const { return SOAP_TYPE___ns1__setRawData; }
        /** Constructor with member initializations */
        __ns1__setRawData()
        {
          ns1__setRawData = (_ns1__setRawData *)0;
        }
        /** Friend allocator used by soap_new___ns1__setRawData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setRawData * SOAP_FMAC2 soap_instantiate___ns1__setRawData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* OGService.h:3284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (187)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* OGService.h:3284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (188)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* OGService.h:3284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (190)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* OGService.h:3284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (193)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* OGService.h:3284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (194)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* OGService.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* OGService.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* OGService.h:176 */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (19)
typedef char xsd__byte;
#endif

/* OGService.h:179 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (20)
typedef unsigned char xsd__unsignedByte;
#endif

/* OGService.h:182 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (21)
typedef std::string xsd__ID;
#endif

/* OGService.h:192 */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (23)
typedef std::string xsd__IDREF;
#endif

/* OGService.h:209 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (26)
typedef std::string xsd__anyURI;
#endif

/* OGService.h:247 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (34)
typedef std::string xsd__decimal;
#endif

/* OGService.h:264 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (38)
typedef std::string xsd__duration;
#endif

/* OGService.h:506 */
#ifndef SOAP_TYPE_ns3__char
#define SOAP_TYPE_ns3__char (94)
typedef int ns3__char;
#endif

/* OGService.h:519 */
#ifndef SOAP_TYPE_ns3__duration
#define SOAP_TYPE_ns3__duration (96)
typedef std::string ns3__duration;
#endif

/* OGService.h:531 */
#ifndef SOAP_TYPE_ns3__guid
#define SOAP_TYPE_ns3__guid (98)
typedef std::string ns3__guid;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (19)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (46)
#endif

/* ns3__char has binding name 'ns3__char' for type 'ns3:char' */
#ifndef SOAP_TYPE_ns3__char
#define SOAP_TYPE_ns3__char (94)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (44)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (41)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (37)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (20)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (17)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (53)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (16)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (51)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (33)
#endif

/* enum ns4__Side has binding name 'ns4__Side' for type 'ns4:Side' */
#ifndef SOAP_TYPE_ns4__Side
#define SOAP_TYPE_ns4__Side (100)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (30)
#endif

/* _ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring has binding name '_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring' for type '' */
#ifndef SOAP_TYPE__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE__ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (120)
#endif

/* _ns5__ArrayOfKeyValueOfintint_KeyValueOfintint has binding name '_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint' for type '' */
#ifndef SOAP_TYPE__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint
#define SOAP_TYPE__ns5__ArrayOfKeyValueOfintint_KeyValueOfintint (117)
#endif

/* ns4__Side_ has binding name 'ns4__Side_' for type 'ns4:Side' */
#ifndef SOAP_TYPE_ns4__Side_
#define SOAP_TYPE_ns4__Side_ (101)
#endif

/* ns3__guid__ has binding name 'ns3__guid__' for type 'ns3:guid' */
#ifndef SOAP_TYPE_ns3__guid__
#define SOAP_TYPE_ns3__guid__ (99)
#endif

/* ns3__guid has binding name 'ns3__guid' for type 'ns3:guid' */
#ifndef SOAP_TYPE_ns3__guid
#define SOAP_TYPE_ns3__guid (98)
#endif

/* ns3__duration__ has binding name 'ns3__duration__' for type 'ns3:duration' */
#ifndef SOAP_TYPE_ns3__duration__
#define SOAP_TYPE_ns3__duration__ (97)
#endif

/* ns3__duration has binding name 'ns3__duration' for type 'ns3:duration' */
#ifndef SOAP_TYPE_ns3__duration
#define SOAP_TYPE_ns3__duration (96)
#endif

/* ns3__char__ has binding name 'ns3__char__' for type 'ns3:char' */
#ifndef SOAP_TYPE_ns3__char__
#define SOAP_TYPE_ns3__char__ (95)
#endif

/* ns5__ArrayOfKeyValueOfstringstring has binding name 'ns5__ArrayOfKeyValueOfstringstring' for type 'ns5:ArrayOfKeyValueOfstringstring' */
#ifndef SOAP_TYPE_ns5__ArrayOfKeyValueOfstringstring
#define SOAP_TYPE_ns5__ArrayOfKeyValueOfstringstring (93)
#endif

/* ns5__ArrayOfKeyValueOfintint has binding name 'ns5__ArrayOfKeyValueOfintint' for type 'ns5:ArrayOfKeyValueOfintint' */
#ifndef SOAP_TYPE_ns5__ArrayOfKeyValueOfintint
#define SOAP_TYPE_ns5__ArrayOfKeyValueOfintint (92)
#endif

/* ns5__ArrayOfstring has binding name 'ns5__ArrayOfstring' for type 'ns5:ArrayOfstring' */
#ifndef SOAP_TYPE_ns5__ArrayOfstring
#define SOAP_TYPE_ns5__ArrayOfstring (91)
#endif

/* ns5__ArrayOfint has binding name 'ns5__ArrayOfint' for type 'ns5:ArrayOfint' */
#ifndef SOAP_TYPE_ns5__ArrayOfint
#define SOAP_TYPE_ns5__ArrayOfint (90)
#endif

/* ns4__Glove_x002eConfiguration_x002eProfile has binding name 'ns4__Glove_x002eConfiguration_x002eProfile' for type 'ns4:Glove.Configuration.Profile' */
#ifndef SOAP_TYPE_ns4__Glove_x002eConfiguration_x002eProfile
#define SOAP_TYPE_ns4__Glove_x002eConfiguration_x002eProfile (89)
#endif

/* ns4__Glove_x002eConfiguration has binding name 'ns4__Glove_x002eConfiguration' for type 'ns4:Glove.Configuration' */
#ifndef SOAP_TYPE_ns4__Glove_x002eConfiguration
#define SOAP_TYPE_ns4__Glove_x002eConfiguration (88)
#endif

/* ns4__Glove has binding name 'ns4__Glove' for type 'ns4:Glove' */
#ifndef SOAP_TYPE_ns4__Glove
#define SOAP_TYPE_ns4__Glove (87)
#endif

/* ns4__ArrayOfGlove has binding name 'ns4__ArrayOfGlove' for type 'ns4:ArrayOfGlove' */
#ifndef SOAP_TYPE_ns4__ArrayOfGlove
#define SOAP_TYPE_ns4__ArrayOfGlove (86)
#endif

/* _ns1__setRawDataResponse has binding name '_ns1__setRawDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__setRawDataResponse
#define SOAP_TYPE__ns1__setRawDataResponse (85)
#endif

/* _ns1__setRawData has binding name '_ns1__setRawData' for type '' */
#ifndef SOAP_TYPE__ns1__setRawData
#define SOAP_TYPE__ns1__setRawData (84)
#endif

/* _ns1__setIMUStatusResponse has binding name '_ns1__setIMUStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__setIMUStatusResponse
#define SOAP_TYPE__ns1__setIMUStatusResponse (83)
#endif

/* _ns1__setIMUStatus has binding name '_ns1__setIMUStatus' for type '' */
#ifndef SOAP_TYPE__ns1__setIMUStatus
#define SOAP_TYPE__ns1__setIMUStatus (82)
#endif

/* _ns1__startIMUResponse has binding name '_ns1__startIMUResponse' for type '' */
#ifndef SOAP_TYPE__ns1__startIMUResponse
#define SOAP_TYPE__ns1__startIMUResponse (81)
#endif

/* _ns1__startIMU has binding name '_ns1__startIMU' for type '' */
#ifndef SOAP_TYPE__ns1__startIMU
#define SOAP_TYPE__ns1__startIMU (80)
#endif

/* _ns1__resetFlexorsResponse has binding name '_ns1__resetFlexorsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__resetFlexorsResponse
#define SOAP_TYPE__ns1__resetFlexorsResponse (79)
#endif

/* _ns1__resetFlexors has binding name '_ns1__resetFlexors' for type '' */
#ifndef SOAP_TYPE__ns1__resetFlexors
#define SOAP_TYPE__ns1__resetFlexors (78)
#endif

/* _ns1__setThresholdResponse has binding name '_ns1__setThresholdResponse' for type '' */
#ifndef SOAP_TYPE__ns1__setThresholdResponse
#define SOAP_TYPE__ns1__setThresholdResponse (77)
#endif

/* _ns1__setThreshold has binding name '_ns1__setThreshold' for type '' */
#ifndef SOAP_TYPE__ns1__setThreshold
#define SOAP_TYPE__ns1__setThreshold (76)
#endif

/* _ns1__confirmCalibrationResponse has binding name '_ns1__confirmCalibrationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__confirmCalibrationResponse
#define SOAP_TYPE__ns1__confirmCalibrationResponse (75)
#endif

/* _ns1__confirmCalibration has binding name '_ns1__confirmCalibration' for type '' */
#ifndef SOAP_TYPE__ns1__confirmCalibration
#define SOAP_TYPE__ns1__confirmCalibration (74)
#endif

/* _ns1__calibrateFlexorsResponse has binding name '_ns1__calibrateFlexorsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__calibrateFlexorsResponse
#define SOAP_TYPE__ns1__calibrateFlexorsResponse (73)
#endif

/* _ns1__calibrateFlexors has binding name '_ns1__calibrateFlexors' for type '' */
#ifndef SOAP_TYPE__ns1__calibrateFlexors
#define SOAP_TYPE__ns1__calibrateFlexors (72)
#endif

/* _ns1__removeFlexorResponse has binding name '_ns1__removeFlexorResponse' for type '' */
#ifndef SOAP_TYPE__ns1__removeFlexorResponse
#define SOAP_TYPE__ns1__removeFlexorResponse (71)
#endif

/* _ns1__removeFlexor has binding name '_ns1__removeFlexor' for type '' */
#ifndef SOAP_TYPE__ns1__removeFlexor
#define SOAP_TYPE__ns1__removeFlexor (70)
#endif

/* _ns1__addFlexorResponse has binding name '_ns1__addFlexorResponse' for type '' */
#ifndef SOAP_TYPE__ns1__addFlexorResponse
#define SOAP_TYPE__ns1__addFlexorResponse (69)
#endif

/* _ns1__addFlexor has binding name '_ns1__addFlexor' for type '' */
#ifndef SOAP_TYPE__ns1__addFlexor
#define SOAP_TYPE__ns1__addFlexor (68)
#endif

/* _ns1__ActivateManyResponse has binding name '_ns1__ActivateManyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ActivateManyResponse
#define SOAP_TYPE__ns1__ActivateManyResponse (67)
#endif

/* _ns1__ActivateMany has binding name '_ns1__ActivateMany' for type '' */
#ifndef SOAP_TYPE__ns1__ActivateMany
#define SOAP_TYPE__ns1__ActivateMany (66)
#endif

/* _ns1__DisconnectResponse has binding name '_ns1__DisconnectResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DisconnectResponse
#define SOAP_TYPE__ns1__DisconnectResponse (65)
#endif

/* _ns1__Disconnect has binding name '_ns1__Disconnect' for type '' */
#ifndef SOAP_TYPE__ns1__Disconnect
#define SOAP_TYPE__ns1__Disconnect (64)
#endif

/* _ns1__ConnectResponse has binding name '_ns1__ConnectResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ConnectResponse
#define SOAP_TYPE__ns1__ConnectResponse (63)
#endif

/* _ns1__Connect has binding name '_ns1__Connect' for type '' */
#ifndef SOAP_TYPE__ns1__Connect
#define SOAP_TYPE__ns1__Connect (62)
#endif

/* _ns1__ActivateResponse has binding name '_ns1__ActivateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ActivateResponse
#define SOAP_TYPE__ns1__ActivateResponse (61)
#endif

/* _ns1__Activate has binding name '_ns1__Activate' for type '' */
#ifndef SOAP_TYPE__ns1__Activate
#define SOAP_TYPE__ns1__Activate (60)
#endif

/* _ns1__SaveGloveResponse has binding name '_ns1__SaveGloveResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SaveGloveResponse
#define SOAP_TYPE__ns1__SaveGloveResponse (59)
#endif

/* _ns1__SaveGlove has binding name '_ns1__SaveGlove' for type '' */
#ifndef SOAP_TYPE__ns1__SaveGlove
#define SOAP_TYPE__ns1__SaveGlove (58)
#endif

/* _ns1__RefreshGlovesResponse has binding name '_ns1__RefreshGlovesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RefreshGlovesResponse
#define SOAP_TYPE__ns1__RefreshGlovesResponse (57)
#endif

/* _ns1__RefreshGloves has binding name '_ns1__RefreshGloves' for type '' */
#ifndef SOAP_TYPE__ns1__RefreshGloves
#define SOAP_TYPE__ns1__RefreshGloves (56)
#endif

/* _ns1__GetGlovesResponse has binding name '_ns1__GetGlovesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetGlovesResponse
#define SOAP_TYPE__ns1__GetGlovesResponse (55)
#endif

/* _ns1__GetGloves has binding name '_ns1__GetGloves' for type '' */
#ifndef SOAP_TYPE__ns1__GetGloves
#define SOAP_TYPE__ns1__GetGloves (54)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (52)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (50)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (49)
#endif

/* xsd__unsignedByte_ has binding name 'xsd__unsignedByte_' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (48)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (47)
#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (45)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (43)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (42)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (40)
#endif

/* xsd__duration_ has binding name 'xsd__duration_' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (39)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (38)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (36)
#endif

/* xsd__decimal_ has binding name 'xsd__decimal_' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (35)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (34)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (32)
#endif

/* xsd__byte_ has binding name 'xsd__byte_' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (31)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (29)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (28)
#endif

/* xsd__anyURI_ has binding name 'xsd__anyURI_' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (27)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (26)
#endif

/* xsd__QName_ has binding name 'xsd__QName_' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (25)
#endif

/* xsd__IDREF_ has binding name 'xsd__IDREF_' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (24)
#endif

/* xsd__IDREF has binding name 'xsd__IDREF' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (23)
#endif

/* xsd__ID_ has binding name 'xsd__ID_' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (22)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (21)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (15)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (13)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (194)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (193)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (190)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (188)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (187)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (196)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (195)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (189)
#endif

/* _ns1__setRawData * has binding name 'PointerTo_ns1__setRawData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__setRawData
#define SOAP_TYPE_PointerTo_ns1__setRawData (183)
#endif

/* _ns1__setIMUStatus * has binding name 'PointerTo_ns1__setIMUStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__setIMUStatus
#define SOAP_TYPE_PointerTo_ns1__setIMUStatus (179)
#endif

/* _ns1__startIMU * has binding name 'PointerTo_ns1__startIMU' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__startIMU
#define SOAP_TYPE_PointerTo_ns1__startIMU (175)
#endif

/* _ns1__resetFlexors * has binding name 'PointerTo_ns1__resetFlexors' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__resetFlexors
#define SOAP_TYPE_PointerTo_ns1__resetFlexors (171)
#endif

/* _ns1__setThreshold * has binding name 'PointerTo_ns1__setThreshold' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__setThreshold
#define SOAP_TYPE_PointerTo_ns1__setThreshold (167)
#endif

/* _ns1__confirmCalibration * has binding name 'PointerTo_ns1__confirmCalibration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__confirmCalibration
#define SOAP_TYPE_PointerTo_ns1__confirmCalibration (163)
#endif

/* _ns1__calibrateFlexors * has binding name 'PointerTo_ns1__calibrateFlexors' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__calibrateFlexors
#define SOAP_TYPE_PointerTo_ns1__calibrateFlexors (159)
#endif

/* _ns1__removeFlexor * has binding name 'PointerTo_ns1__removeFlexor' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__removeFlexor
#define SOAP_TYPE_PointerTo_ns1__removeFlexor (155)
#endif

/* _ns1__addFlexor * has binding name 'PointerTo_ns1__addFlexor' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__addFlexor
#define SOAP_TYPE_PointerTo_ns1__addFlexor (151)
#endif

/* _ns1__ActivateMany * has binding name 'PointerTo_ns1__ActivateMany' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ActivateMany
#define SOAP_TYPE_PointerTo_ns1__ActivateMany (147)
#endif

/* _ns1__Disconnect * has binding name 'PointerTo_ns1__Disconnect' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Disconnect
#define SOAP_TYPE_PointerTo_ns1__Disconnect (143)
#endif

/* _ns1__Connect * has binding name 'PointerTo_ns1__Connect' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Connect
#define SOAP_TYPE_PointerTo_ns1__Connect (139)
#endif

/* _ns1__Activate * has binding name 'PointerTo_ns1__Activate' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Activate
#define SOAP_TYPE_PointerTo_ns1__Activate (135)
#endif

/* _ns1__SaveGlove * has binding name 'PointerTo_ns1__SaveGlove' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SaveGlove
#define SOAP_TYPE_PointerTo_ns1__SaveGlove (131)
#endif

/* _ns1__RefreshGloves * has binding name 'PointerTo_ns1__RefreshGloves' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RefreshGloves
#define SOAP_TYPE_PointerTo_ns1__RefreshGloves (127)
#endif

/* _ns1__GetGloves * has binding name 'PointerTo_ns1__GetGloves' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetGloves
#define SOAP_TYPE_PointerTo_ns1__GetGloves (123)
#endif

/* std::vector<_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring> * has binding name 'PointerTostd__vectorTemplateOf_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (122)
#endif

/* std::vector<_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint> * has binding name 'PointerTostd__vectorTemplateOf_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint (119)
#endif

/* ns5__ArrayOfKeyValueOfstringstring * has binding name 'PointerTons5__ArrayOfKeyValueOfstringstring' for type 'ns5:ArrayOfKeyValueOfstringstring' */
#ifndef SOAP_TYPE_PointerTons5__ArrayOfKeyValueOfstringstring
#define SOAP_TYPE_PointerTons5__ArrayOfKeyValueOfstringstring (114)
#endif

/* ns5__ArrayOfKeyValueOfintint * has binding name 'PointerTons5__ArrayOfKeyValueOfintint' for type 'ns5:ArrayOfKeyValueOfintint' */
#ifndef SOAP_TYPE_PointerTons5__ArrayOfKeyValueOfintint
#define SOAP_TYPE_PointerTons5__ArrayOfKeyValueOfintint (113)
#endif

/* ns4__Glove_x002eConfiguration_x002eProfile * has binding name 'PointerTons4__Glove_x002eConfiguration_x002eProfile' for type 'ns4:Glove.Configuration.Profile' */
#ifndef SOAP_TYPE_PointerTons4__Glove_x002eConfiguration_x002eProfile
#define SOAP_TYPE_PointerTons4__Glove_x002eConfiguration_x002eProfile (112)
#endif

/* ns5__ArrayOfstring * has binding name 'PointerTons5__ArrayOfstring' for type 'ns5:ArrayOfstring' */
#ifndef SOAP_TYPE_PointerTons5__ArrayOfstring
#define SOAP_TYPE_PointerTons5__ArrayOfstring (111)
#endif

/* enum ns4__Side * has binding name 'PointerTons4__Side' for type 'ns4:Side' */
#ifndef SOAP_TYPE_PointerTons4__Side
#define SOAP_TYPE_PointerTons4__Side (110)
#endif

/* ns4__Glove_x002eConfiguration * has binding name 'PointerTons4__Glove_x002eConfiguration' for type 'ns4:Glove.Configuration' */
#ifndef SOAP_TYPE_PointerTons4__Glove_x002eConfiguration
#define SOAP_TYPE_PointerTons4__Glove_x002eConfiguration (109)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (108)
#endif

/* ns5__ArrayOfint * has binding name 'PointerTons5__ArrayOfint' for type 'ns5:ArrayOfint' */
#ifndef SOAP_TYPE_PointerTons5__ArrayOfint
#define SOAP_TYPE_PointerTons5__ArrayOfint (106)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (105)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (104)
#endif

/* ns4__Glove * has binding name 'PointerTons4__Glove' for type 'ns4:Glove' */
#ifndef SOAP_TYPE_PointerTons4__Glove
#define SOAP_TYPE_PointerTons4__Glove (103)
#endif

/* ns4__ArrayOfGlove * has binding name 'PointerTons4__ArrayOfGlove' for type 'ns4:ArrayOfGlove' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfGlove
#define SOAP_TYPE_PointerTons4__ArrayOfGlove (102)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (18)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring>  has binding name 'std__vectorTemplateOf_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE_std__vectorTemplateOf_ns5__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (121)
#endif

/* std::vector<_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint>  has binding name 'std__vectorTemplateOf_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint
#define SOAP_TYPE_std__vectorTemplateOf_ns5__ArrayOfKeyValueOfintint_KeyValueOfintint (118)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (116)
#endif

/* std::vector<int>  has binding name 'std__vectorTemplateOfint' for type 'xsd:int' */
#ifndef SOAP_TYPE_std__vectorTemplateOfint
#define SOAP_TYPE_std__vectorTemplateOfint (115)
#endif

/* std::vector<ns4__Glove *>  has binding name 'std__vectorTemplateOfPointerTons4__Glove' for type 'ns4:Glove' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__Glove
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__Glove (107)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
